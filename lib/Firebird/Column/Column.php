<?php

namespace FirebdPHP\Firebird\Column;

use Exception;
use FirebdPHP\Firebird\Utils\Output;
use FirebdPHP\Firebird\Utils\StringUtils;

class Column
{
    private string $name;
    private string $type;
    private bool $nullable = false;
    private ?int $limit = null;
    private bool $generated = false;
    private bool $unique = false;
    private mixed $defaultValue;

    // For primary keys
    private bool $primary = false;

    // For foreign keys 
    private array $reference = [];
    private ?string $referencedTable = null;
    private ?string $referencedField = null;

    public function __construct(
        string $name,
        string $type,
        mixed $defaultValue,
        ?int $limit = null,
        bool $generated = false,
        bool $primary = false,
        array $reference = [],
        ?bool $unique = false
    ) {
        $this->name = $name;
        $this->type = $type;
        $this->limit = $limit;
        $this->generated = $generated;
        $this->defaultValue = $defaultValue;
        // We can use a question mark at the end of the type option to define if the field is nullable
        $this->nullable = $type[-1] === "?";
        $this->unique = $unique;
        // For primary keys
        $this->primary = $primary;
        // For foreign keys
        $this->setReference($reference);
    }

    public function asString()
    {
        // Gets type full definition. Ex: type varchar + limit 255 becomes varchar(255) not null
        [$type, $nullability] = $this->getTypeData();
        $primaryKeyData = $this->getPrimaryKeyData();
        $uniqueness = $this->getUniqueness();
        $defaultValue = $this->getDefaultValue();

        $column = "$this->name $type $defaultValue $nullability $primaryKeyData $uniqueness";

        // Remove blank spaces at the end
        $column = StringUtils::removeInlineSpaces($column);
        return $column;
    }


    /**
     * A field is not unique by default, if it is set to be unique but is a primary key theres no need to put "unique" explicitly.
     */
    private function getUniqueness()
    {
        $uniqueness = ($this->unique && !$this->primary) ? "unique" : "";
        return $uniqueness;
    }

    /**
     * Check type nullability and limits, so we can get a clear type definition
     */
    private function getTypeData()
    {
        // Ex: "int?" becomes ["int", ""] and "int" becomes ["int", "not null"]
        [$type, $notNull] = $this->getTypeAndNullability();
        // In types like varchar we need to specify a limit of characters
        $type = $this->checkTypeLimit($type);
        return [$type, $notNull];
    }

    /**
     * Returns not null if the field isn't nullable or a primary key 
     * @return array [string $type, string $nullability]
     */
    private function getTypeAndNullability()
    {
        // if type?
        if ($this->nullable) {
            // Returns the type without the question mark when it's nullable and isn't a primary key or doesn't have a default
            $cleanType = substr($this->type, 0, -1);
            return [$cleanType, ""];
        }

        // if type
        // Primary keys can't be null by default - IGNORE NULLABLE 
        if ($this->primary) return [$this->type, ""];
        // A field with a default value doesn't need the "not null" string
        if ($this->defaultValue) return [$this->type, ""];
        // When we don't have the question mark:
        if (!$this->nullable) return [$this->type, "not null"];
    }

    /**
     * Check if the type needs a specified limit. If so, we set the limit, else we just return the original type string
     */
    private function checkTypeLimit(string $type)
    {
        $needLimits = ["varchar", "char"];
        if (in_array($type, $needLimits)) {
            $name = $this->name;
            $limit = $this->limit;
            if (!$limit) {
                Output::error();
                throw new Exception("Cannot create field $name of type $type without limit value");
            };
            return "$type($limit)";
        }
        return $type;
    }

    /**
     * Returns the correct string for an auto generated primary key.
     * Ex: primary key + increment = generated by default as identity primary key
     * If it isn't a primary key it will return an empty string
     */
    private function getPrimaryKeyData()
    {
        if (!$this->primary) return "";
        if ($this->generated) return "generated by default as identity primary key";
        return "primary key";
    }

    /**
     * Set the values used for creating foreign keys. We receive an array with
     * the name, field and onDelete politics and set the values in the object.
     */
    private function setReference(array $reference)
    {
        if (!$reference) return [];
        if (!$reference["table"]) {
            Output::error();
            throw new Exception("Cannot create foreign key without specifying a table");
        }
        
        $this->referencedTable = $reference["table"];
        $this->referencedField = $reference["field"];
        $this->onDelete = $reference["onDelete"] ?? "sdf";
    }

    private function getDefaultValue()
    {
        if (!$this->defaultValue) return "";
        if ($this->defaultValue && $this->nullable) {
            Output::error();
            throw new Exception("Field $this->name cannot be nullable because it has a default value");
        }

        if ($this->defaultValue === "now") {
            Output::warn("Default value 'now' means 'current_timestamp' in the firebird database");
            $this->defaultValue = "current_timestamp";
        }

        $default = match ($this->type) {
            "varchar", "char" => "'$this->defaultValue'",
            default => $this->defaultValue,
        };

        return "default $default";
    }
}
